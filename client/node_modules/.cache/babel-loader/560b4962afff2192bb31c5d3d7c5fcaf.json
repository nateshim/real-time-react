{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nconst {\n  parse,\n  serialize\n} = require('pg-protocol');\n\nconst flushBuffer = serialize.flush();\nconst syncBuffer = serialize.sync();\nconst endBuffer = serialize.end(); // TODO(bmc) support binary mode at some point\n\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.stream = config.stream || new net.Socket();\n    this._keepAlive = config.keepAlive;\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    this.lastBuffer = false;\n    this.parsedStatements = {};\n    this.ssl = config.ssl || false;\n    this._ending = false;\n    this._emitMessage = false;\n    var self = this;\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n  }\n\n  connect(port, host) {\n    var self = this;\n    this._connecting = true;\n    this.stream.setNoDelay(true);\n    this.stream.connect(port, host);\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n      }\n\n      self.emit('connect');\n    });\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return;\n      }\n\n      self.emit('error', error);\n    };\n\n    this.stream.on('error', reportStreamError);\n    this.stream.on('close', function () {\n      self.emit('end');\n    });\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream);\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8');\n\n      switch (responseCode) {\n        case 'S':\n          // Server supports SSL connections, continue with a secure connection\n          break;\n\n        case 'N':\n          // Server does not support SSL connections\n          self.stream.end();\n          return self.emit('error', new Error('The server does not support SSL connections'));\n\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end();\n          return self.emit('error', new Error('There was an error establishing an SSL connection'));\n      }\n\n      var tls = require('tls');\n\n      const options = {\n        socket: self.stream\n      };\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl);\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key;\n        }\n      }\n\n      if (net.isIP(host) === 0) {\n        options.servername = host;\n      }\n\n      try {\n        self.stream = tls.connect(options);\n      } catch (err) {\n        return self.emit('error', err);\n      }\n\n      self.attachListeners(self.stream);\n      self.stream.on('error', reportStreamError);\n      self.emit('sslconnect');\n    });\n  }\n\n  attachListeners(stream) {\n    stream.on('end', () => {\n      this.emit('end');\n    });\n    parse(stream, msg => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n      if (this._emitMessage) {\n        this.emit('message', msg);\n      }\n\n      this.emit(eventName, msg);\n    });\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl());\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config));\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey));\n  }\n\n  password(password) {\n    this._send(serialize.password(password));\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false;\n    }\n\n    return this.stream.write(buffer);\n  }\n\n  query(text) {\n    this._send(serialize.query(text));\n  } // send parse message\n\n\n  parse(query) {\n    this._send(serialize.parse(query));\n  } // send bind message\n\n\n  bind(config) {\n    this._send(serialize.bind(config));\n  } // send execute message\n\n\n  execute(config) {\n    this._send(serialize.execute(config));\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer);\n    }\n  }\n\n  sync() {\n    this._ending = true;\n\n    this._send(flushBuffer);\n\n    this._send(syncBuffer);\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true;\n\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end();\n      return;\n    }\n\n    return this.stream.write(endBuffer, () => {\n      this.stream.end();\n    });\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg));\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg));\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk));\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone());\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg));\n  }\n\n}\n\nmodule.exports = Connection;","map":{"version":3,"sources":["/Users/nathanaelshim/Desktop/pixit/node_modules/pg/lib/connection.js"],"names":["net","require","EventEmitter","util","parse","serialize","flushBuffer","flush","syncBuffer","sync","endBuffer","end","Connection","constructor","config","stream","Socket","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","ssl","_ending","_emitMessage","self","on","eventName","connect","port","host","_connecting","setNoDelay","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","Error","tls","options","socket","Object","assign","key","isIP","servername","err","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\n\nconst { parse, serialize } = require('pg-protocol')\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n    this.stream = config.stream || new net.Socket()\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    var self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    var self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      var tls = require('tls')\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      if (net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = tls.connect(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    stream.on('end', () => {\n      this.emit('end')\n    })\n    parse(stream, (msg) => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(flushBuffer)\n    this._send(syncBuffer)\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n"]},"metadata":{},"sourceType":"script"}