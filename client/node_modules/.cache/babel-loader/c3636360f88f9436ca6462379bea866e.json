{"ast":null,"code":"import History from './History';\nimport PixelCollection from './PixelCollection';\nexport default class PixelEditor {\n  constructor(_canvas, width, height, tool, history = new History()) {\n    this._canvas = _canvas;\n    this.width = width;\n    this.height = height;\n    this.tool = tool;\n    this.history = history;\n    this._previousPosition = {\n      x: -1,\n      y: -1\n    };\n    this._pixels = new PixelCollection(this.width);\n    this._canvas.width = this.width;\n    this._canvas.height = this.height;\n    this._canvas.style.width = '100%';\n    this._canvas.style.imageRendering = 'pixelated';\n\n    this._canvas.addEventListener('mouseup', this.mouseup.bind(this));\n\n    this._canvas.addEventListener('mousedown', this.mousedown.bind(this));\n\n    this._canvas.addEventListener('mousemove', this.mousemove.bind(this));\n\n    this._canvas.addEventListener('touchstart', this.touchstart.bind(this));\n\n    this._canvas.addEventListener('touchmove', this.touchmove.bind(this));\n\n    const context = this._canvas.getContext('2d');\n\n    if (!context) {\n      throw new Error('Unable to get get context from canvas');\n    }\n\n    this._context = context;\n  }\n\n  mouseup(e) {\n    const position = this.mousePosition(e);\n    this.tool.handlePointerUp(position, this);\n  }\n\n  mousedown(e) {\n    const position = this.mousePosition(e);\n    this.tool.handlePointerDown(position, this);\n    this._previousPosition = { ...position\n    };\n  }\n\n  mousemove(e) {\n    const position = this.mousePosition(e);\n\n    if (position.x !== this._previousPosition.x || position.y !== this._previousPosition.y) {\n      this._previousPosition = { ...position\n      };\n      this.tool.handlePointerMove(position, this);\n    }\n  }\n\n  touchstart(e) {\n    const position = this.touchPosition(e);\n    this.tool.handlePointerDown(position, this);\n    this._previousPosition = { ...position\n    };\n  }\n\n  touchmove(e) {\n    const position = this.touchPosition(e);\n\n    if (position.x !== this._previousPosition.x || position.y !== this._previousPosition.y) {\n      this._previousPosition = { ...position\n      };\n      this.tool.handlePointerMove(position, this);\n    }\n  }\n\n  touchPosition(event) {\n    event.preventDefault();\n    const [touch] = event.touches;\n\n    const rect = this._canvas.getBoundingClientRect();\n\n    const x = Math.round(touch.clientX - rect.left) * this._canvas.width / this._canvas.clientWidth | 0; // tslint:disable-line\n\n    const y = Math.round(touch.clientY - rect.top) * this._canvas.height / this._canvas.clientHeight | 0; // tslint:disable-line\n\n    return {\n      x,\n      y\n    };\n  }\n\n  mousePosition(event) {\n    const x = event.offsetX * this._canvas.width / this._canvas.clientWidth | 0; // tslint:disable-line\n\n    const y = event.offsetY * this._canvas.height / this._canvas.clientHeight | 0; // tslint:disable-line\n\n    return {\n      x,\n      y\n    };\n  }\n\n  get(x, y) {\n    const color = this._pixels.get(x, y);\n\n    return {\n      x,\n      y,\n      color\n    };\n  }\n\n  set(pixels, logToHistory = true) {\n    const prev = [];\n\n    for (const {\n      x,\n      y,\n      color\n    } of pixels) {\n      if (color) {\n        this._context.fillStyle = color;\n\n        this._context.fillRect(x, y, 1, 1);\n      } else {\n        this._context.clearRect(x, y, 1, 1);\n      }\n\n      prev.push({\n        x,\n        y,\n        color: this._pixels.get(x, y)\n      });\n\n      this._pixels.set({\n        x,\n        y,\n        color\n      });\n    }\n\n    if (logToHistory) {\n      this.history.push({\n        next: pixels,\n        prev\n      });\n    }\n  }\n\n  get pixels() {\n    const pixels = [];\n\n    for (const {\n      x,\n      y\n    } of this._pixels) {\n      pixels.push(this.get(x, y));\n    }\n\n    return pixels;\n  }\n\n  clear() {\n    this._context.clearRect(0, 0, this.width, this.height);\n\n    this.history.push({\n      next: [],\n      prev: this.pixels\n    });\n    this._pixels = new PixelCollection(this.width);\n  }\n\n  undo() {\n    const pixels = this.history.prev();\n\n    if (pixels) {\n      this.set(pixels, false);\n    }\n  }\n\n  redo() {\n    const pixels = this.history.next();\n\n    if (pixels) {\n      this.set(pixels, false);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/nathanaelshim/Desktop/real-time-react/client/src/PixelEditor.js"],"names":["History","PixelCollection","PixelEditor","constructor","_canvas","width","height","tool","history","_previousPosition","x","y","_pixels","style","imageRendering","addEventListener","mouseup","bind","mousedown","mousemove","touchstart","touchmove","context","getContext","Error","_context","e","position","mousePosition","handlePointerUp","handlePointerDown","handlePointerMove","touchPosition","event","preventDefault","touch","touches","rect","getBoundingClientRect","Math","round","clientX","left","clientWidth","clientY","top","clientHeight","offsetX","offsetY","get","color","set","pixels","logToHistory","prev","fillStyle","fillRect","clearRect","push","next","clear","undo","redo"],"mappings":"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","sourcesContent":["import History from './History';\nimport PixelCollection from './PixelCollection';\nexport default class PixelEditor {\n    constructor(_canvas, width, height, tool, history = new History()) {\n        this._canvas = _canvas;\n        this.width = width;\n        this.height = height;\n        this.tool = tool;\n        this.history = history;\n        this._previousPosition = { x: -1, y: -1 };\n        this._pixels = new PixelCollection(this.width);\n        this._canvas.width = this.width;\n        this._canvas.height = this.height;\n        this._canvas.style.width = '100%';\n        this._canvas.style.imageRendering = 'pixelated';\n        this._canvas.addEventListener('mouseup', this.mouseup.bind(this));\n        this._canvas.addEventListener('mousedown', this.mousedown.bind(this));\n        this._canvas.addEventListener('mousemove', this.mousemove.bind(this));\n        this._canvas.addEventListener('touchstart', this.touchstart.bind(this));\n        this._canvas.addEventListener('touchmove', this.touchmove.bind(this));\n        const context = this._canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Unable to get get context from canvas');\n        }\n        this._context = context;\n    }\n    mouseup(e) {\n        const position = this.mousePosition(e);\n        this.tool.handlePointerUp(position, this);\n    }\n    mousedown(e) {\n        const position = this.mousePosition(e);\n        this.tool.handlePointerDown(position, this);\n        this._previousPosition = { ...position };\n    }\n    mousemove(e) {\n        const position = this.mousePosition(e);\n        if (position.x !== this._previousPosition.x || position.y !== this._previousPosition.y) {\n            this._previousPosition = { ...position };\n            this.tool.handlePointerMove(position, this);\n        }\n    }\n    touchstart(e) {\n        const position = this.touchPosition(e);\n        this.tool.handlePointerDown(position, this);\n        this._previousPosition = { ...position };\n    }\n    touchmove(e) {\n        const position = this.touchPosition(e);\n        if (position.x !== this._previousPosition.x || position.y !== this._previousPosition.y) {\n            this._previousPosition = { ...position };\n            this.tool.handlePointerMove(position, this);\n        }\n    }\n    touchPosition(event) {\n        event.preventDefault();\n        const [touch] = event.touches;\n        const rect = this._canvas.getBoundingClientRect();\n        const x = ((Math.round(touch.clientX - rect.left) * this._canvas.width) / this._canvas.clientWidth) | 0; // tslint:disable-line\n        const y = ((Math.round(touch.clientY - rect.top) * this._canvas.height) / this._canvas.clientHeight) | 0; // tslint:disable-line\n        return { x, y };\n    }\n    mousePosition(event) {\n        const x = ((event.offsetX * this._canvas.width) / this._canvas.clientWidth) | 0; // tslint:disable-line\n        const y = ((event.offsetY * this._canvas.height) / this._canvas.clientHeight) | 0; // tslint:disable-line\n        return { x, y };\n    }\n    get(x, y) {\n        const color = this._pixels.get(x, y);\n        return { x, y, color };\n    }\n    set(pixels, logToHistory = true) {\n        const prev = [];\n        for (const { x, y, color } of pixels) {\n            if (color) {\n                this._context.fillStyle = color;\n                this._context.fillRect(x, y, 1, 1);\n            }\n            else {\n                this._context.clearRect(x, y, 1, 1);\n            }\n            prev.push(({ x, y, color: this._pixels.get(x, y) }));\n            this._pixels.set({ x, y, color });\n        }\n        if (logToHistory) {\n            this.history.push({ next: pixels, prev });\n        }\n    }\n    get pixels() {\n        const pixels = [];\n        for (const { x, y } of this._pixels) {\n            pixels.push(this.get(x, y));\n        }\n        return pixels;\n    }\n    clear() {\n        this._context.clearRect(0, 0, this.width, this.height);\n        this.history.push({ next: [], prev: this.pixels });\n        this._pixels = new PixelCollection(this.width);\n    }\n    undo() {\n        const pixels = this.history.prev();\n        if (pixels) {\n            this.set(pixels, false);\n        }\n    }\n    redo() {\n        const pixels = this.history.next();\n        if (pixels) {\n            this.set(pixels, false);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}